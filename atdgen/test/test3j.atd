(* JSON support only *)

type json <ocaml module="Yojson.Safe"> = abstract
type dyn <ocaml module="Yojson.Safe" t="json"> = abstract

type t = {
  foo: int;
  bar: json;
  baz: dyn
}

type unixtime_list = int <ocaml repr="float"> list


(*** JSON records using one field to indicate the type of other fields ***)

type patch = {
  ?patch1: int nullable option;
  ?patch2: int nullable option;
  ?patch3: int nullable option;
} <json keep_nulls>

(* Test json adapters *)

(*
   The real json representation uses an object with a `"type"` field
   equal to `"a"` or `"b"`. Types `a` and `b` are incompatible
   with one another.

   See normalize/restore functions in `adapter.ml`.
*)
type adapted = [
  | A <json name="a"> of a
  | B <json name="b"> of b
] <json adapter="atdgen_runtime.util.json.adapter.type_field.default">

type a = {
  thing: string;
  other_thing: bool;
}

type b = {
  thing: int; (* field name found in `a` with another type! *)
}
