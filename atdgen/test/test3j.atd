(* JSON support only *)

type json <ocaml module="Yojson.Safe"> = abstract
type dyn <ocaml module="Yojson.Safe" t="json"> = abstract

type t = {
  foo: int;
  bar: json;
  baz: dyn
}

type unixtime_list = int <ocaml repr="float"> list


(*** JSON records using one field to indicate the type of other fields ***)

(*
   Support for the following JSON records:
   { "type": "integer", data: 123 }    -> { data = `Integer 123 }
   { "type": "string", data: "abc" }   -> { data = `String "abc" }
*)
type simple = {
  data <json tag_field="type">: integer_or_string;
    (* JSON object has one extra field "type" that must
       contain the constructor for the OCaml variant.

       integer_or_string is a variant type, broken into 2 fields in the
       JSON representation.
    *)
}

type integer_or_string = [
  | Integer <json name="integer"> of int
  | String <json name="string"> of string
]

type patch = {
  ?patch1: int nullable option;
  ?patch2: int nullable option;
  ?patch3: int nullable option;
} <json keep_nulls>

(* Test json adapters *)

(*
   The real json representation uses an object with a `"type"` field
   equal to `"a"` or `"b"`. Types `a` and `b` are incompatible
   with one another.

   See normalize/restore functions in `adapter.ml`.
*)
type adapted = [
  | A of a
  | B of b
] <json adapter="adapter.type_field">

type a = {
  thing: string;
  other_thing: bool;
}

type b = {
  thing: int; (* field name found in `a` with another type! *)
}
