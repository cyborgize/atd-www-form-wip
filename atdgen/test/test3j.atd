(* JSON support only *)

type json <ocaml module="Yojson.Safe"> = abstract
type dyn <ocaml module="Yojson.Safe" t="json"> = abstract

type t = {
  foo: int;
  bar: json;
  baz: dyn
}

type unixtime_list = int <ocaml repr="float"> list

type patch = {
  ?patch1: int nullable option;
  ?patch2: int nullable option;
  ?patch3: int nullable option;
} <json keep_nulls>

(*** Test json adapters ***)

(*
   The real json representation uses an object with a `"type"` field
   equal to `"a"` or `"b"`. Types `a` and `b` are incompatible
   with one another.

   See normalize/restore functions in `adapter.ml`.
*)
type adapted = [
  | A <json name="a"> of a
  | B <json name="b"> of b
] <json adapter.ocaml="Atdgen_runtime.Util.Json.Adapter.Type_field.Default">

(*
   Test substitute for the retired tag_field feature.
*)

type tf_variant = [
  | A <json name="a"> of int
  | B <json name="b"> of int
]

(*
   Sample raw json: { "the_type": "a", "the_value": 123, "etc": "blah" }
   Sample normalized json: { "the_value": ["a", 123], "etc": "blah" }
   Test_lib.Tag_field_example takes care of the conversion
   between the two forms.
*)
type tf_record = {
  the_value : tf_variant;
  etc : string;
} <json adapter.ocaml="Test_lib.Tag_field_example">

(* Test record field shadowing and disambiguation. *)

type a = {
  thing: string;
  other_thing: bool;
}

type b = {
  thing: int; (* field name found in `a` with another type! *)
}
